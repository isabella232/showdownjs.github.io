{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Showdown documentation Showdown is a JavaScript Markdown to HTML converter, based on the original works by John Gruber. Showdown can be used on the client-side (in the browser) or server-side (with Node.js). Live demo http://demo.showdownjs.com/ Who uses Showdown (or a fork) Antmarky GoogleCloudPlatform Meteor StackExchange - forked as PageDown docular md-page QCObjects and some others Installation To install Showdown, follow the instructions from the Installation guide . License ShowdownJS v 2.0 is release under the MIT version. Previous versions are release under BSD.","title":"Introduction"},{"location":"#showdown-documentation","text":"Showdown is a JavaScript Markdown to HTML converter, based on the original works by John Gruber. Showdown can be used on the client-side (in the browser) or server-side (with Node.js).","title":"Showdown documentation"},{"location":"#live-demo","text":"http://demo.showdownjs.com/","title":"Live demo"},{"location":"#who-uses-showdown-or-a-fork","text":"Antmarky GoogleCloudPlatform Meteor StackExchange - forked as PageDown docular md-page QCObjects and some others","title":"Who uses Showdown (or a fork)"},{"location":"#installation","text":"To install Showdown, follow the instructions from the Installation guide .","title":"Installation"},{"location":"#license","text":"ShowdownJS v 2.0 is release under the MIT version. Previous versions are release under BSD.","title":"License"},{"location":"compatibility/","text":"Browsers Showdown has been tested successfully with: Firefox 1.5 and 2.0 Chrome 12.0 Internet Explorer 6 and 7 Safari 2.0.4 Opera 8.54 and 9.10 Netscape 8.1.2 Konqueror 3.5.4 Generally, Showdown should work in any browser that supports ECMA 262 3 rd Edition (JavaScript 1.5). The converter might even work in things that aren't web browsers, like Acrobat. However, no promises. Node.js Showdown is intended to work on any supported Node.js version (see the Node.js releases schedule . Previous versions may also be supported, but no accomodations are made to ensure this.","title":"Compatibility"},{"location":"compatibility/#browsers","text":"Showdown has been tested successfully with: Firefox 1.5 and 2.0 Chrome 12.0 Internet Explorer 6 and 7 Safari 2.0.4 Opera 8.54 and 9.10 Netscape 8.1.2 Konqueror 3.5.4 Generally, Showdown should work in any browser that supports ECMA 262 3 rd Edition (JavaScript 1.5). The converter might even work in things that aren't web browsers, like Acrobat. However, no promises.","title":"Browsers"},{"location":"compatibility/#nodejs","text":"Showdown is intended to work on any supported Node.js version (see the Node.js releases schedule . Previous versions may also be supported, but no accomodations are made to ensure this.","title":"Node.js"},{"location":"donations/","text":"ShowdownJS is a free library and it will remain free forever . However, maintaining and improving the library costs time and money. If you like our work and find it useful, please donate through PayPal . Your contributions are greatly appreciated and will help us with the development of this awesome library.","title":"Donations"},{"location":"event_system/","text":"Event System Introduction The Event Object Events Events are raised when a subparser is run (or about to be run). Within a subparser, the events always follow a certain order (sequence). For instance, .before events always run before .captureStart . Each subparser raises several events sequentially: .start : always runs except it subparser is disabled Raised when the subparser has started , but no capturing or any modification to the text was done. Always runs (except if the subparser is deactivated through options). Properties : property type access description input string read The full text that was passed to the subparser output string write The full text with modification that will be passed along the chain regexp null matches null Usually you would want to use this event if you wish to change the input to the subparser .captureStart : might not be run ; Raised when a regex match is found and a capture was successful. Some normalization and modification of the regex captured groups might be performed. Might not be run if no regex match is found. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regexp RegExp readonly Regular Expression used to capture groups matches object read/write Matches groups. Changes to this object are reflected in the output Usually you would want to use this event if you wish to modify a certain subparser behavior. Exs: remove all title attributes from links; change indentation of code blocks; etc... .captureEnd : might not be run ; Raised after the modifications to the captured text are done but before the replacement is introduced in the document. Might not be run if no regex match is found. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regexp RegExp readonly Regular Expression used to capture groups matches object read/write Keypairs of matches groups. Changes to this object are reflected in the output attributes object read/write Attributes to add to the HTML output .beforeHash : might not be run ; Raised before the output is hashed. Always run (except if the subparser was deactivated through options), even if no hashing is performed. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regexp null matches null Usually you would want to use this event if you wish change the subparser output before it is hashed .end : always runs ; Raised when the subparser has finished its work and is about to exit. Always runs (except if the subparser is deactivated through options). Properties : property type access description input string read The partial/full text with the subparser modifications output string write The text that will be passed to other subparsers regexp null matches null Usually you would want to use this event if you wish change the subparser hashed output Special Events There are some special events that are useful for \"positioning\" a listener extension in the main chain of events. Usually these extensions introduce new syntax that, due to precedence These events are always guaranteed to be called, regardless of options or circumstances. .before_{subparserName} : always runs Raised just before the {subparserName} is about to be entered . Properties : property type access description input string read The full text that was passed to the subparser output string write The full text with modification that will be passed along the chain regexp null matches null .after .{subparserName}: always runs ; Raised when the {subparserName} has exited and before the next one is called. Properties : property type access description input string read The partial/full text with the subparser modifications output string write The text that will be passed to other subparsers regexp null matches null Notes There are 2 main differences between before.{subparserName} and {subparserName}.start . before.{subparserName} is always guaranteed to be called, even if the subparser is disabled, while {subparserName}.start doesn't. ex: makehtml.before.strikethrough is always called even if the option strikethrough is false before.{subparserName} is only raised once in a span context while {subparserName}.start is raised everytime {subparserName} is called. As a rule of thumb, Events List","title":"Event System"},{"location":"event_system/#event-system","text":"","title":"Event System"},{"location":"event_system/#introduction","text":"","title":"Introduction"},{"location":"event_system/#the-event-object","text":"","title":"The Event Object"},{"location":"event_system/#events","text":"Events are raised when a subparser is run (or about to be run). Within a subparser, the events always follow a certain order (sequence). For instance, .before events always run before .captureStart . Each subparser raises several events sequentially: .start : always runs except it subparser is disabled Raised when the subparser has started , but no capturing or any modification to the text was done. Always runs (except if the subparser is deactivated through options). Properties : property type access description input string read The full text that was passed to the subparser output string write The full text with modification that will be passed along the chain regexp null matches null Usually you would want to use this event if you wish to change the input to the subparser .captureStart : might not be run ; Raised when a regex match is found and a capture was successful. Some normalization and modification of the regex captured groups might be performed. Might not be run if no regex match is found. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regexp RegExp readonly Regular Expression used to capture groups matches object read/write Matches groups. Changes to this object are reflected in the output Usually you would want to use this event if you wish to modify a certain subparser behavior. Exs: remove all title attributes from links; change indentation of code blocks; etc... .captureEnd : might not be run ; Raised after the modifications to the captured text are done but before the replacement is introduced in the document. Might not be run if no regex match is found. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regexp RegExp readonly Regular Expression used to capture groups matches object read/write Keypairs of matches groups. Changes to this object are reflected in the output attributes object read/write Attributes to add to the HTML output .beforeHash : might not be run ; Raised before the output is hashed. Always run (except if the subparser was deactivated through options), even if no hashing is performed. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regexp null matches null Usually you would want to use this event if you wish change the subparser output before it is hashed .end : always runs ; Raised when the subparser has finished its work and is about to exit. Always runs (except if the subparser is deactivated through options). Properties : property type access description input string read The partial/full text with the subparser modifications output string write The text that will be passed to other subparsers regexp null matches null Usually you would want to use this event if you wish change the subparser hashed output","title":"Events"},{"location":"event_system/#special-events","text":"There are some special events that are useful for \"positioning\" a listener extension in the main chain of events. Usually these extensions introduce new syntax that, due to precedence These events are always guaranteed to be called, regardless of options or circumstances. .before_{subparserName} : always runs Raised just before the {subparserName} is about to be entered . Properties : property type access description input string read The full text that was passed to the subparser output string write The full text with modification that will be passed along the chain regexp null matches null .after .{subparserName}: always runs ; Raised when the {subparserName} has exited and before the next one is called. Properties : property type access description input string read The partial/full text with the subparser modifications output string write The text that will be passed to other subparsers regexp null matches null","title":"Special Events"},{"location":"event_system/#notes","text":"There are 2 main differences between before.{subparserName} and {subparserName}.start . before.{subparserName} is always guaranteed to be called, even if the subparser is disabled, while {subparserName}.start doesn't. ex: makehtml.before.strikethrough is always called even if the option strikethrough is false before.{subparserName} is only raised once in a span context while {subparserName}.start is raised everytime {subparserName} is called. As a rule of thumb,","title":"Notes"},{"location":"event_system/#events-list","text":"","title":"Events List"},{"location":"quickstart/","text":"To quickstart with Showdown, install it as a package (for server-side) or include it to your browser (client-side) via CDN: Installation Server-side npm bower NuGet npm install showdown bower install showdown PM> Install-Package showdownjs More information about the package you can find on the NuGet website . Client-side jsDelivr cdnjs unpkg https://cdn.jsdelivr.net/npm/showdown@<version>/dist/showdown.min.js Showndown page on jsDelivr https://cdnjs.cloudflare.com/ajax/libs/showdown/<version>/showdown.min.js Showndown page on cdnjs https://unpkg.com/showdown/dist/showdown.min.js Showndown page on unpkg Replace <version> with an actual full length version you're interested in. For example, 2.0.3 . Usage Once installed, you can use Showndown according to the chosen method: Server-side Node.js code output var showdown = require ( 'showdown' ), converter = new showdown . Converter (), text = '# hello, markdown!' , html = converter . makeHtml ( text ); < h1 id = \"hellomarkdown\" > hello, markdown! </ h1 > Client-side Browser code output var converter = new showdown . Converter (), text = '# hello, markdown!' , html = converter . makeHtml ( text ); < h1 id = \"hellomarkdown\" > hello, markdown! </ h1 > Other installation methods Tarball You can download the latest tarball directly from releases . Previous versions If you're looking for Showdown prior to version 1.0.0, you can find them in the legacy branch . Changelog The full changelog is available here .","title":"Quickstart"},{"location":"quickstart/#installation","text":"","title":"Installation"},{"location":"quickstart/#server-side","text":"npm bower NuGet npm install showdown bower install showdown PM> Install-Package showdownjs More information about the package you can find on the NuGet website .","title":"Server-side"},{"location":"quickstart/#client-side","text":"jsDelivr cdnjs unpkg https://cdn.jsdelivr.net/npm/showdown@<version>/dist/showdown.min.js Showndown page on jsDelivr https://cdnjs.cloudflare.com/ajax/libs/showdown/<version>/showdown.min.js Showndown page on cdnjs https://unpkg.com/showdown/dist/showdown.min.js Showndown page on unpkg Replace <version> with an actual full length version you're interested in. For example, 2.0.3 .","title":"Client-side"},{"location":"quickstart/#usage","text":"Once installed, you can use Showndown according to the chosen method:","title":"Usage"},{"location":"quickstart/#server-side_1","text":"Node.js code output var showdown = require ( 'showdown' ), converter = new showdown . Converter (), text = '# hello, markdown!' , html = converter . makeHtml ( text ); < h1 id = \"hellomarkdown\" > hello, markdown! </ h1 >","title":"Server-side"},{"location":"quickstart/#client-side_1","text":"Browser code output var converter = new showdown . Converter (), text = '# hello, markdown!' , html = converter . makeHtml ( text ); < h1 id = \"hellomarkdown\" > hello, markdown! </ h1 >","title":"Client-side"},{"location":"quickstart/#other-installation-methods","text":"","title":"Other installation methods"},{"location":"quickstart/#tarball","text":"You can download the latest tarball directly from releases .","title":"Tarball"},{"location":"quickstart/#previous-versions","text":"If you're looking for Showdown prior to version 1.0.0, you can find them in the legacy branch .","title":"Previous versions"},{"location":"quickstart/#changelog","text":"The full changelog is available here .","title":"Changelog"}]}