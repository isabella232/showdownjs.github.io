{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Showdown documentation Showdown is a JavaScript Markdown to HTML converter, based on the original works by John Gruber. Showdown can be used on the client-side (in the browser) or server-side (with Node.js). Live demo http://demo.showdownjs.com/ ShowdownJS is a free library and it will remain free forever. However, maintaining and improving the library costs time and money. If you like our work and find it useful, please donate through PayPal . Your contributions are greatly appreciated and will help us with the development of this awesome library. Who uses Showdown (or a fork) GoogleCloudPlatform Meteor StackExchange - forked as PageDown docular md-page QCObjects Antmarky and some others License ShowdownJS v 2.0 is release under the MIT version. Previous versions are release under BSD.","title":"Home"},{"location":"#showdown-documentation","text":"Showdown is a JavaScript Markdown to HTML converter, based on the original works by John Gruber. Showdown can be used on the client-side (in the browser) or server-side (with Node.js).","title":"Showdown documentation"},{"location":"#live-demo","text":"http://demo.showdownjs.com/ ShowdownJS is a free library and it will remain free forever. However, maintaining and improving the library costs time and money. If you like our work and find it useful, please donate through PayPal . Your contributions are greatly appreciated and will help us with the development of this awesome library.","title":"Live demo"},{"location":"#who-uses-showdown-or-a-fork","text":"GoogleCloudPlatform Meteor StackExchange - forked as PageDown docular md-page QCObjects Antmarky and some others","title":"Who uses Showdown (or a fork)"},{"location":"#license","text":"ShowdownJS v 2.0 is release under the MIT version. Previous versions are release under BSD.","title":"License"},{"location":"event_system/","text":"Event System Introduction The Event Object Events Events are raised when a subparser is run (or about to be run). Within a subparser, the events always follow a certain order (sequence). For instance, .before events always run before .captureStart . Each subparser raises several events sequentially: .start : always runs except it subparser is disabled Raised when the subparser has started , but no capturing or any modification to the text was done. Always runs (except if the subparser is deactivated through options). Properties : property type access description input string read The full text that was passed to the subparser output string write The full text with modification that will be passed along the chain regex null matches null Usually you would want to use this event if you wish to change the input to the subparser .captureStart : might not be run ; Raised when a regex match is found and a capture was successful. Some normalization and modification of the regex captured groups might be performed. Might not be run if no regex match is found. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regex RegExp readonly Regular Expression used to capture groups matches object read/write Matches groups. Changes to this object are reflected in the output Usually you would want to use this event if you wish to modify a certain subparser behavior. Exs: remove all title attributes from links; change indentation of code blocks; etc... .captureEnd : might not be run ; Raised after the modifications to the captured text are done but before the replacement is introduced in the document. Might not be run if no regex match is found. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regex RegExp readonly Regular Expression used to capture groups matches object read/write Keypairs of matches groups. Changes to this object are reflected in the output attributes object read/write Attributes to add to the HTML output .beforeHash : might not be run ; Raised before the output is hashed. Always run (except if the subparser was deactivated through options), even if no hashing is performed. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regex null matches null Usually you would want to use this event if you wish change the subparser output before it is hashed .end : always runs ; Raised when the subparser has finished its work and is about to exit. Always runs (except if the subparser is deactivated through options). Properties : property type access description input string read The partial/full text with the subparser modifications output string write The text that will be passed to other subparsers regex null matches null Usually you would want to use this event if you wish change the subparser hashed output Special Events There are some special events that are useful for \"positioning\" a listener extension in the main chain of events. Usually these extensions introduce new syntax that, due to precedence These events are always guaranteed to be called, regardless of options or circumstances. .before_{subparserName} : always runs Raised just before the {subparserName} is about to be entered . Properties : property type access description input string read The full text that was passed to the subparser output string write The full text with modification that will be passed along the chain regex null matches null .after .{subparserName}: always runs ; Raised when the {subparserName} has exited and before the next one is called. Properties : property type access description input string read The partial/full text with the subparser modifications output string write The text that will be passed to other subparsers regex null matches null Notes There are 2 main differences between before.{subparserName} and {subparserName}.start . before.{subparserName} is always guaranteed to be called, even if the subparser is disabled, while {subparserName}.start doesn't. ex: makehtml.before.strikethrough is always called even if the option strikethrough is false before.{subparserName} is only raised once in a span context while {subparserName}.start is raised everytime {subparserName} is called. As a rule of thumb, Events List","title":"Event System"},{"location":"event_system/#event-system","text":"","title":"Event System"},{"location":"event_system/#introduction","text":"","title":"Introduction"},{"location":"event_system/#the-event-object","text":"","title":"The Event Object"},{"location":"event_system/#events","text":"Events are raised when a subparser is run (or about to be run). Within a subparser, the events always follow a certain order (sequence). For instance, .before events always run before .captureStart . Each subparser raises several events sequentially: .start : always runs except it subparser is disabled Raised when the subparser has started , but no capturing or any modification to the text was done. Always runs (except if the subparser is deactivated through options). Properties : property type access description input string read The full text that was passed to the subparser output string write The full text with modification that will be passed along the chain regex null matches null Usually you would want to use this event if you wish to change the input to the subparser .captureStart : might not be run ; Raised when a regex match is found and a capture was successful. Some normalization and modification of the regex captured groups might be performed. Might not be run if no regex match is found. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regex RegExp readonly Regular Expression used to capture groups matches object read/write Matches groups. Changes to this object are reflected in the output Usually you would want to use this event if you wish to modify a certain subparser behavior. Exs: remove all title attributes from links; change indentation of code blocks; etc... .captureEnd : might not be run ; Raised after the modifications to the captured text are done but before the replacement is introduced in the document. Might not be run if no regex match is found. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regex RegExp readonly Regular Expression used to capture groups matches object read/write Keypairs of matches groups. Changes to this object are reflected in the output attributes object read/write Attributes to add to the HTML output .beforeHash : might not be run ; Raised before the output is hashed. Always run (except if the subparser was deactivated through options), even if no hashing is performed. Properties : property type access description input string read The captured text output string write The text that will be passed to the subparser/other listeners regex null matches null Usually you would want to use this event if you wish change the subparser output before it is hashed .end : always runs ; Raised when the subparser has finished its work and is about to exit. Always runs (except if the subparser is deactivated through options). Properties : property type access description input string read The partial/full text with the subparser modifications output string write The text that will be passed to other subparsers regex null matches null Usually you would want to use this event if you wish change the subparser hashed output","title":"Events"},{"location":"event_system/#special-events","text":"There are some special events that are useful for \"positioning\" a listener extension in the main chain of events. Usually these extensions introduce new syntax that, due to precedence These events are always guaranteed to be called, regardless of options or circumstances. .before_{subparserName} : always runs Raised just before the {subparserName} is about to be entered . Properties : property type access description input string read The full text that was passed to the subparser output string write The full text with modification that will be passed along the chain regex null matches null .after .{subparserName}: always runs ; Raised when the {subparserName} has exited and before the next one is called. Properties : property type access description input string read The partial/full text with the subparser modifications output string write The text that will be passed to other subparsers regex null matches null","title":"Special Events"},{"location":"event_system/#notes","text":"There are 2 main differences between before.{subparserName} and {subparserName}.start . before.{subparserName} is always guaranteed to be called, even if the subparser is disabled, while {subparserName}.start doesn't. ex: makehtml.before.strikethrough is always called even if the option strikethrough is false before.{subparserName} is only raised once in a span context while {subparserName}.start is raised everytime {subparserName} is called. As a rule of thumb,","title":"Notes"},{"location":"event_system/#events-list","text":"","title":"Events List"}]}